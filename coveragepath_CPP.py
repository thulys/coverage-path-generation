#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Thu Aug 22 11:50:19 2019

@author: ysli
reference:
    the idea is from 'Efficient complete coverage of a known arbitrary environment with applications to aerial operations' by Ioannis Rekleitis

features:   
    consider all critical points as nodes
    consider each cell as an edge connected to its critical points
    consider width^2/area as cost of each edge(cell)
    formulate CPP model to find cells needed to be splitted so that they form a Eular circuit
    
    after getting a Eular circuit, the sequence is given by a greedy algorithm. 
    when arrives at a node, firstly checks if there is unvisited circles connected to it. 
    if yes, visits the one whose vertice is closest to the last generated waypoint.
    otherwise, the one whose vertice is closest to the last generated waypoint from all unvisited edges connected to the node
    
    the path is generated by applying 'back and forth' pattern
    
"""
import numpy as np
import matplotlib.pyplot as plt
import math
from sympy import Point, Line, Polygon,Segment
import gurobipy as grb
import Queue
import time

#check if the input boundary points define one polygon without crossline
def checkcrossline(polygon):
    sides=polygon.sides
    count=0
    for i in range(len(sides)-1):
        for j in range(i+1,len(sides)):
            if(len(sides[i].intersection(sides[j]))==1):
                count=count+1
    if(count==len(polygon.vertices)):
        return False
    else:
        return True
    
#rearrange boundary points so that they define a polygon without crossing lines
#return boundary points in correct sequence
def formpolygon(coord):
    num=len(coord)
    coord=coord[np.lexsort((coord[:,1],coord[:,0]))]
    vertex=np.zeros((0,2))
    vertex=np.append(vertex,coord[0].reshape(1,2),axis=0)
    vertex=np.append(vertex,coord[num-1].reshape(1,2),axis=0)
    for i in range(1,num-1):
        split=(coord[i][0]-coord[0][0])/(coord[num-1][0]-coord[0][0])*(coord[num-1][1]-coord[0][1])+coord[0][1]
        if(coord[i][1]>split):
            up=True
        else:
            up=False
        if(up):
            j=0
            while(j<len(vertex)):
                if(vertex[j][0]<=coord[i][0]):
                    j=j+1
                else:
                    vertex=np.insert(vertex, j, values=coord[i], axis=0)
                    break
            if(j==len(vertex)):
                vertex=np.insert(vertex, j-1 , values=coord[i], axis=0)
        else:
            j=np.argwhere(vertex[:,0]==coord[num-1][0])[0][0]
            while(j<len(vertex)):
                if(vertex[j][0]>=coord[i][0]):
                    j=j+1
                else:
                    vertex=np.insert(vertex, j, values=coord[i], axis=0)
                    break
            if(j==len(vertex)):
                vertex=np.append(vertex, coord[i].reshape(1,2), axis=0)
    return vertex

#find all Points that equals to the target
#return -1 for none, single point or a list of points
def findpoint(points,goal):
    i=0
    index=[]
    for point in points:
        if(point.equals(goal)):
            index.append(i)
        else:
            i=i+1
    if(len(index)==1):
        return index[0]
    if(len(index)>1):
        return index
    if(len(index)==0):
        return -1
    
#split input polygon into two parts by input line
#return leftpolygon,rightpolygon or uppolygon,downpolygon or original polygon,none(if no intersection)
def splitpolygon(polygon,line):
    crosspoint=polygon.intersection(line)
    sides=polygon.sides
    vertices=polygon.vertices
    if(len(crosspoint)==2 and isinstance(crosspoint[1],Point)):
        if not(line.is_parallel(xaxis)):
            if(crosspoint[0].y>crosspoint[1].y):
                upcross=crosspoint[0]
                downcross=crosspoint[1]
            else:
                downcross=crosspoint[0]
                upcross=crosspoint[1]
            i=0
            for side in sides:
                if(side.contains(upcross)):
                    if(upcross.x<side.p1.x or(upcross.x==side.p1.x and upcross.x>side.p2.x)):                        
                        rightupindex=i
                        leftupindex=i+1
                    else:
                        leftupindex=i
                        rightupindex=i+1
                if(side.contains(downcross)):
                    if(downcross.x<side.p1.x or(downcross.x==side.p1.x and downcross.x>side.p2.x)):
                        rightdownindex=i
                        leftdownindex=i+1
                    else:
                        leftdownindex=i
                        rightdownindex=i+1
                i=i+1
            rightpt=list([upcross,downcross])
            if(rightdownindex<=rightupindex):
                rightpt.extend(vertices[rightdownindex:rightupindex+1])
            else:
                rightpt.extend(vertices[rightdownindex:len(vertices)])
                rightpt.extend(vertices[0:rightupindex+1])
            if(leftupindex<=leftdownindex):
                leftpt=list(vertices[leftupindex:leftdownindex+1])
            else:
                leftpt=list(vertices[leftupindex:len(vertices)])
                leftpt.extend(vertices[0:leftdownindex+1])
            leftpt.extend([downcross,upcross])
            leftpolygon=Polygon(*leftpt)
            rightpolygon=Polygon(*rightpt)
            return leftpolygon,rightpolygon
        else:
            if(crosspoint[0].x>crosspoint[1].x):
                rightcross=crosspoint[0]
                leftcross=crosspoint[1]
            else:
                rightcross=crosspoint[1]
                leftcross=crosspoint[0]
            for side in sides:
                if(side.contains(rightcross)):
                    if(rightcross.y>side.p1.y or(rightcross.y==side.p1.y and rightcross.y<side.p2.y)):
                        rightdownindex=findpoint(vertices,side.p1)
                        rightupindex=findpoint(vertices,side.p2)
                    else:
                        rightupindex=findpoint(vertices,side.p1)
                        rightdownindex=findpoint(vertices,side.p2)
                if(side.contains(leftcross)):
                    if(leftcross.y>side.p1.y or(leftcross.y==side.p1.y and leftcross.y<side.p2.y)):
                        leftdownindex=findpoint(vertices,side.p1)
                        leftupindex=findpoint(vertices,side.p2)
                    else:
                        leftupindex=findpoint(vertices,side.p1)
                        leftdownindex=findpoint(vertices,side.p2)
            uppt=list([leftcross,rightcross])
            if(rightupindex<=leftupindex):
                uppt.extend(vertices[rightupindex:leftupindex+1])
            else:
                uppt.extend(vertices[rightupindex:len(vertices)])
                uppt.extend(vertices[0:leftupindex+1])
            if(leftdownindex<=rightdownindex):
                downpt=list(vertices[leftdownindex:rightdownindex+1])
            else:
                downpt=list(vertices[leftdownindex:len(vertices)])
                downpt.extend(vertices[0:rightdownindex+1])
            downpt.extend([rightcross,leftcross])
            uppolygon=Polygon(*uppt)
            downpolygon=Polygon(*downpt)
            return uppolygon,downpolygon
    else:
        return polygon,None
    
#remove the area of obstacle from the area of interest
def minuspolygon(polygon,obs,pt):
    verticesp=polygon.vertices
    sides=polygon.sides
    for side in sides:
        if(side.contains(Point(pt))):
            break       
    indexp1=findpoint(verticesp,side.p1)
    indexp2=findpoint(verticesp,side.p2)
    if(indexp1>indexp2):
        indexp=indexp1
    else:
        indexp=indexp2
    verticeso=obs.vertices
    verticeso.reverse()
    indexo=findpoint(verticeso,Point(pt))
    verticesp[indexp:indexp]=iter(verticeso[0:indexo+1])
    verticesp[indexp:indexp]=iter(verticeso[indexo:len(verticeso)])
    polygon=Polygon(*verticesp)
    return polygon

'''
LP model input:
cellcost=[0.25,4/3,4/3,4]
ane=[
     [1,0,0,0],
     [1,1,1,0],
     [0,1,1,1],
     [0,0,0,1]]
kn=[1,1,1,1]
ane,kn,criticalpoints=addtomodel(cells,cellcost,criticalpos)
'''
#compute data required by the LP model
def addtomodel(cells,cellcost,criticalpoints):
    i=0
    for cell in cells:
        bound=cell.bounds
        width=bound[2]-bound[0]
        cellcost.append(width*width/cell.area)
    i=i+1
    ane=np.zeros((len(criticalpoints),len(cells)))
    kn=np.zeros((len(criticalpoints),1))
    i=0
    for pt in criticalpoints:
        j=0
        for cell in cells:       
            bound=cell.bounds
            if(bound[0]==pt.x or bound[2]==pt.x):
                ane[i][j]=1
            j=j+1
        i=i+1
    for i in range(len(criticalpoints)):
        kn[i]=sum(ane[i])%2
    return ane,kn

def printsolution(m,var):
    if m.status == grb.GRB.Status.OPTIMAL:
        print('totalCost: %g' % m.objVal)
        print('cell copied:')
        for f in var:
            if (var[f].X!=0):
                #print('%s' % (pathvar[f].VarName))
                if(f[0]=='x'):
                    print 'copy cell %d for %d time' %(f[1],var[f].X)
    else:
        print('No solution')

#formulate and solve LP model
def solveLP(cellcost,ane,kn):
    m=grb.Model('ILP_CPP')
    vars={}
    for i in range(len(cellcost)):
        vars['x',i]= m.addVar(obj=cellcost[i], vtype=grb.GRB.INTEGER,name='x'+str(i))
    for i in range(len(kn)):
        vars['w',i]=m.addVar( vtype=grb.GRB.INTEGER,name='w'+str(i))
    for i in range(len(kn)):
        m.addConstr((grb.quicksum(vars['x',j]*ane[i][j] for j in range(len(cellcost)))-2*vars['w',i])==kn[i])
    m.update()
    m._vars = vars
    m.optimize()
    return m,m._vars

#given a sequence of points, return the indexs of left,bottom,right,top extremities in a list
def findbound(vertices):
    leftmost=float('inf')
    rightmost=float('-inf')
    topmost=float('-inf')
    buttommost=float('inf')
    for i in range(len(vertices)):
        vertice=vertices[i]
        if(vertice.x<leftmost):
            leftmost=vertice.x
            leftindex=i
        if(vertice.x>rightmost):
            rightmost=vertice.x
            rightindex=i
        if(vertice.y>topmost):
            topmost=vertice.y
            topindex=i
        if(vertice.y<buttommost):
            buttommost=vertice.y
            buttomindex=i
    return [leftindex,buttomindex,rightindex,topindex]

#form a list of vertical lines given a list of points
def formperpenicularlines(xpos):
    xpos=xpos.reshape(len(xpos),1)
    xpts=np.insert(xpos,1,[0],axis=1)
    xpts=map(Point,xpts)
    cutlines=[]
    for pt in xpts:
        cutline=xaxis.perpendicular_line(pt)
        cutlines.append(cutline)
    return cutlines

#find coverage path inside a convex polygon, return two paths, start from leftup and leftdown
def createallwaypoint(rboundary,inputwidth):
    bounds=rboundary.bounds
    cutnum=float(math.ceil(round((round(bounds[2],6)-round(bounds[0],6))/inputwidth,6)))
    width=(round(bounds[2],6)-round(bounds[0],6))/cutnum 
    cutpos=np.arange(bounds[0]+width,bounds[2]+width,width)
    pointpos=np.arange(bounds[0]+width/2,bounds[2]+width/2,width)
    cutlines=formperpenicularlines(cutpos)
    #form sub-polygons cut by cutlines
    subpolygons=[]
    remain=rboundary
    for line in cutlines:
        subpolygon,remain=splitpolygon(remain,line)
        subpolygons.append(subpolygon)
        if not (remain):
            break
    #design waypoints in subpolygons
    i=0
    waypoints1=[]
    waypoints2=[]
    for polygon in subpolygons:
        sides=polygon.sides
        vertices=polygon.vertices
        lines=[]
        lineindex=[]
        j=0
        for side in sides:
            if(side.is_parallel(yaxis)):
                lineindex.append(j)
                lines.append(side)
            j=j+1
        waypoint=[]
        if(len(lines)==2):#formed by 2 cuts
            #seprate vertices into upper part and lower part
            if(lines[0].p1.x<lines[1].p1.x):
                leftupindex=lineindex[0]
                leftdownindex=(lineindex[0]+1)%len(vertices)
                rightupindex=(lineindex[1]+1)%len(vertices)
                rightdownindex=lineindex[1]
            else:
                rightdownindex=lineindex[0]
                rightupindex=(lineindex[0]+1)%len(vertices)
                leftdownindex=(lineindex[1]+1)%len(vertices)
                leftupindex=lineindex[1]
            if(rightupindex<leftupindex):
                uppoints=list(vertices[rightupindex:leftupindex+1])
            else:
                uppoints=list(vertices[rightupindex:len(vertices)])
                uppoints.extend(vertices[0:leftupindex+1])
            if(leftdownindex<rightdownindex):
                downpoints=list(vertices[leftdownindex:rightdownindex+1])
            else:
                downpoints=list(vertices[leftdownindex:len(vertices)])
                downpoints.extend(vertices[0:leftupindex+1]) 
            upindex=findbound(uppoints)
            downindex=findbound(downpoints)
            upmin=uppoints[upindex[1]].y#ymin
            upmax=uppoints[upindex[3]].y #ymax
            downmin=downpoints[downindex[1]].y
            downmax=downpoints[downindex[3]].y
            if(upmax-downmin<=width):
                waypoint.append(Point(pointpos[i],(upmax+downmin)/2))
            else:
                if(upmax-upmin<=width/2):
                    waypoint.append(Point(pointpos[i],upmax-width/2))
                else:
                    cutpt=Point(pointpos[i],upmax-width/2)
                    cut=yaxis.perpendicular_line(cutpt)
                    crosspoint=polygon.intersection(cut)
                    if(crosspoint[0].x<crosspoint[1].x):
                        leftcross=crosspoint[0]
                        rightcross=crosspoint[1]
                    else:
                        leftcross=crosspoint[1]
                        rightcross=crosspoint[0]
                    if(leftcross.x<=pointpos[i] and rightcross.x>=pointpos[i]):
                        waypoint.append(Point(pointpos[i],upmax-width/2))
                    elif(leftcross.x>pointpos[i]):
                        waypoint.append(leftcross)
                        if(upmin-downmax<=width):
                            waypoint.append(Point(pointpos[i],(upmin+downmax)/2))
                        else:
                            waypoint.append(Point(pointpos[i],upmin-width/2))                                
                    else:
                        waypoint.append(rightcross)
                        if(upmin-downmax<=width):
                            waypoint.append(Point(pointpos[i],(upmin+downmax)/2))
                        else:
                            waypoint.append(Point(pointpos[i],upmin-width/2)) 
                if(downmax-downmin<=width/2):
                    waypoint.append(Point(pointpos[i],downmin+width/2))
                else:
                    cutpt=Point(pointpos[i],downmin+width/2)
                    cut=yaxis.perpendicular_line(cutpt)
                    crosspoint=polygon.intersection(cut)
                    if(crosspoint[0].x<crosspoint[1].x):
                        leftcross=crosspoint[0]
                        rightcross=crosspoint[1]
                    else:
                        leftcross=crosspoint[1]
                        rightcross=crosspoint[0]
                    if(leftcross.x<=pointpos[i] and rightcross.x>=pointpos[i]):
                        waypoint.append(Point(pointpos[i],downmin+width/2))
                    elif(leftcross.x>pointpos[i]):
                        if(upmin-downmax<=width):
                            waypoint.append(Point(pointpos[i],(upmin+downmax)/2))
                        else:
                            waypoint.append(Point(pointpos[i],downmax+width/2))
                        waypoint.append(leftcross)
                    else:
                        if(upmin-downmax<=width):
                            waypoint.append(Point(pointpos[i],(upmin+downmax)/2))
                        else:
                            waypoint.append(Point(pointpos[i],downmax+width/2)) 
                        waypoint.append(rightcross)
        elif(len(lines)==1):
            index=findbound(vertices)
            leftindex=index[0]
            line=lines[0]
            ymax=vertices[index[3]].y
            ymin=vertices[index[1]].y
            xmin=vertices[index[0]].x
            xmax=vertices[index[2]].x
            if(line.contains(vertices[leftindex])):#cut line at left
                if(ymax-ymin<=width):
                    waypoint.append(Point(xmax-width/2,(ymin+ymax)/2))
                else:
                    upcutpt=Point(pointpos[i],ymax-width/2)
                    upcut=yaxis.perpendicular_line(upcutpt)
                    downcutpt=Point(pointpos[i],ymin+width/2)
                    downcut=yaxis.perpendicular_line(downcutpt)
                    rightcutpt=Point(xmax-width/2,0)
                    rightcut=xaxis.perpendicular_line(rightcutpt)
                    upcrosspoint=rightcut.intersection(upcut)
                    if(polygon.encloses_point(upcrosspoint[0])):
                        waypoint.append(upcrosspoint[0])
                    else:
                        crosspoint=polygon.intersection(upcut)
                        if(crosspoint[0].x<crosspoint[1].x):
                            waypoint.append(crosspoint[0])
                        else:
                            waypoint.append(crosspoint[1])
                        crosspoint=polygon.intersection(rightcut)
                        if (crosspoint[0].y>crosspoint[1].y):
                            uppt=crosspoint[0]
                            downpt=crosspoint[1]
                        else:
                            uppt=crosspoint[1]
                            downpt=crosspoint[0]
                        if((uppt.y-downpt.y)<=width):
                            waypoint.append(Segment(uppt,downpt).midpoint)
                        else:
                            waypoint.append(Point(uppt.x,uppt.y-width/2))
                    downcrosspoint=rightcut.intersection(downcut)
                    if(polygon.encloses_point(downcrosspoint[0])):
                        waypoint.append(downcrosspoint[0])
                    else:                   
                        crosspoint=polygon.intersection(rightcut)
                        if (crosspoint[0].y>crosspoint[1].y):
                            uppt=crosspoint[0]
                            downpt=crosspoint[1]
                        else:
                            uppt=crosspoint[1]
                            downpt=crosspoint[0]
                        if((uppt.y-downpt.y)<=width):
                            waypoint.append(Segment(uppt,downpt).midpoint)
                        else:
                            waypoint.append(Point(downpt.x,downpt.y+width/2))
                        crosspoint=polygon.intersection(downcut)
                        if(crosspoint[0].x<crosspoint[1].x):
                            waypoint.append(crosspoint[0])
                        else:
                            waypoint.append(crosspoint[1])                                 
            else:#cut line at right
                if(ymax-ymin<=width):
                    waypoint=[Point(xmin+width/2,(ymin+ymax)/2)]
                else:
                    upcutpt=Point(pointpos[i],ymax-width/2)
                    upcut=yaxis.perpendicular_line(upcutpt)
                    downcutpt=Point(pointpos[i],ymin+width/2)
                    downcut=yaxis.perpendicular_line(downcutpt)
                    leftcutpt=Point(xmin+width/2,0)
                    leftcut=xaxis.perpendicular_line(leftcutpt)
                    upcrosspoint=leftcut.intersection(upcut)
                    if(polygon.encloses_point(upcrosspoint[0])):
                        waypoint.append(upcrosspoint[0])
                    else:
                        crosspoint=polygon.intersection(upcut)
                        if(crosspoint[0].x>crosspoint[1].x):
                            waypoint.append(crosspoint[0])
                        else:
                            waypoint.append(crosspoint[1])
                        crosspoint=polygon.intersection(leftcut)
                        if (crosspoint[0].y>crosspoint[1].y):
                            uppt=crosspoint[0]
                            downpt=crosspoint[1]
                        else:
                            uppt=crosspoint[1]
                            downpt=crosspoint[0]
                        if((uppt.y-downpt.y)<=width):
                            waypoint.append(Segment(uppt,downpt).midpoint)
                        else:
                            waypoint.append(Point(uppt.x,uppt.y-width/2))
                    downcrosspoint=leftcut.intersection(downcut)
                    if(polygon.encloses_point(downcrosspoint[0])):
                        waypoint.append(downcrosspoint[0])
                    else:                   
                        crosspoint=polygon.intersection(leftcut)
                        if (crosspoint[0].y>crosspoint[1].y):
                            uppt=crosspoint[0]
                            downpt=crosspoint[1]
                        else:
                            uppt=crosspoint[1]
                            downpt=crosspoint[0]
                        if((uppt.y-downpt.y)<=width):
                            waypoint.append(Segment(uppt,downpt).midpoint)
                        else:
                            waypoint.append(Point(downpt.x,downpt.y+width/2))
                        crosspoint=polygon.intersection(downcut)
                        if(crosspoint[0].x>crosspoint[1].x):
                            waypoint.append(crosspoint[0])
                        else:
                            waypoint.append(crosspoint[1])             
        else:#width of the area less than sensor width
            bound=polygon.bounds
            if(bound[3]-bound[1]<width):
                waypoint=[Point(pointpos[i],(bound[1]+bound[3])/2)]
            else:
                waypoint=[Point(pointpos[i],bound[3]-width/2),Point(pointpos[i],bound[1]+width/2)]
        i=i+1
        if(i%2==1):
            waypoint.reverse()
        waypoints1.extend(waypoint)
        waypoint.reverse()
        waypoints2.extend(waypoint)
    return waypoints1,waypoints2

#find the path exploring the cell that has least distance traveling from entrance point to exit point   
def singlearearoute(cell,inputwidth,Entrance):
    mintime=float('inf')
    optimalpath=[]
    waypoint1,waypoint2=createallwaypoint(cell,inputwidth)
    time=timeconsume(waypoint1,Entrance)
    if(time<mintime):
        mintime=time
        optimalpath=waypoint1
    rvwaypoint=waypoint1[:]
    rvwaypoint.reverse()
    time=timeconsume(rvwaypoint,Entrance)
    if(time<mintime):
        mintime=time
        optimalpath=rvwaypoint

    time=timeconsume(waypoint2,Entrance)
    if(time<mintime):
        mintime=time
        optimalpath=waypoint2
    rvwaypoint=waypoint2[:]
    rvwaypoint.reverse()
    time=timeconsume(rvwaypoint,Entrance)
    if(time<mintime):
        mintime=time
        optimalpath=rvwaypoint
    return optimalpath

#estimate time cost of the path (take number of turns into consideration)
def timeconsume(waypoint,rentrance):
    length=0
    for i in range(len(waypoint)-1):
        length=length+math.sqrt(pow(waypoint[i].x-waypoint[i+1].x,2)+pow(waypoint[i].y-waypoint[i+1].y,2))
    length=length+waypoint[0].distance(rentrance)
    turnnum=len(waypoint)-1
    return length/velocity+turnnum*turnpanalty

#find the node connected to the input edge, which is not equal to the input node
def findnext(newane,edge,current):
    temp=[x[int(edge)] for x in newane]
    nextnode=temp.index(1)
    if(nextnode==current):
        temp.reverse()
        nextnode=len(temp)-temp.index(1)-1
    return nextnode

#convert Point to array
def pointtoarray(vertices):
    point=[]
    for vertice in vertices:
        point.append([vertice.x,vertice.y])
    return np.array(point)  

#plot cells                              
def plotpolygon(ax,boundary):    
    vertices=list(boundary.vertices)
    vertices.append(vertices[0])
    vertice=pointtoarray(vertices)
    ax.plot(vertice[:,0],vertice[:,1],linewidth=2,color='black',linestyle=':')
    
#plot boundarys
def plotboundary(ax,boundary):    
    vertices=list(boundary.vertices)
    vertices.append(vertices[0])
    vertice=pointtoarray(vertices)
    ax.plot(vertice[:,0],vertice[:,1],linewidth=2,color='black',linestyle='-')
    
#plot waypoints
def plotline(ax,rwaypoints,width):
    point=pointtoarray(rwaypoints) 
    ax.plot(point[:,0],point[:,1],linewidth=1,color='g')
    width=0.1
    for i in range(len(rwaypoints)-1):
        x=[]
        y=[]
        if(rwaypoints[i].x==rwaypoints[i+1].x and rwaypoints[i].y==rwaypoints[i+1].y):
            continue
        else:
            line=Line(rwaypoints[i],rwaypoints[i+1])
            diracp=line.direction.unit
            diracn=diracp.rotate(math.pi/2)
            rectpt1=rwaypoints[i].translate((diracn.x-diracp.x)*width/2,(diracn.y-diracp.y)*width/2)
            rectpt2=rwaypoints[i+1].translate((diracn.x+diracp.x)*width/2,(diracn.y+diracp.y)*width/2)
            rectpt3=rwaypoints[i+1].translate((diracp.x-diracn.x)*width/2,(diracp.y-diracn.y)*width/2)
            rectpt4=rwaypoints[i].translate((-diracp.x-diracn.x)*width/2,(-diracp.y-diracn.y)*width/2)
            x.extend([rectpt1.x,rectpt2.x,rectpt3.x,rectpt4.x])
            y.extend([rectpt1.y,rectpt2.y,rectpt3.y,rectpt4.y])
            ax.fill(x,y,'w',alpha=1)

#sort the vertices according to coordinate x    
def sortvertice(vertices):
    coord=[]
    pts=[]
    for vertice in vertices:
        coord.append([vertice.x,vertice.y]) 
    coord=np.array(coord)
    coord=coord[coord[:,0].argsort()]      
    for pt in coord:
        pts.append(Point(pt[0],pt[1]))
    return pts

#split the polygon by a list of points
def splitCPPpolygon(cell,cutline):
    i=0
    uppoints=[]
    downpoints=[]
    for side in cell.sides:
        if(side.contains(cutline[0])):
            leftupindex=i
            leftdownindex=(i+1)%len(cell.sides)
        if(side.contains(cutline[-1])):
            rightdownindex=i
            rightupindex=(i+1)%len(cell.sides)
        i=i+1
    if(leftupindex>=rightupindex):
        uppoints.extend(cell.vertices[rightupindex:leftupindex+1])
    else:
        uppoints.extend(cell.vertices[rightupindex:len(cell.vertices)])
        uppoints.extend(cell.vertices[0:leftupindex+1])
    uppoints.extend(cutline)
    if(leftdownindex<=rightdownindex):
        downpoints.extend(cell.vertices[leftdownindex:rightdownindex+1])
    else:
        downpoints.extend(cell.vertices[leftdownindex:len(cell.vertices)])
        downpoints.extend(cell.vertices[0:rightdownindex+1])
    cutline.reverse()
    downpoints.extend(cutline)
    downpolygon=Polygon(*downpoints)
    uppolygon=Polygon(*uppoints)
    return downpolygon,uppolygon

#find if there is unvisited circle connected to the inputnode that contains input edge
def checkcycle(newane,visitededge,currentedge,currentnode):
    tempvisited=visitededge[:]
    tempvisited.append(currentedge)
    nextnode=findnext(newane,currentedge,currentnode)
    
    edgeq=Queue.Queue()
    startnode=Queue.Queue()
    for i in range(len(cells)):
        if(newane[nextnode][i]==1):
            edge=i          
            if not(edge in tempvisited):
                edgeq.put(edge)
                startnode.put(nextnode)
    tempnode=nextnode
    while not edgeq.empty():
        edge=edgeq.get()
        tempnode=findnext(newane,edge,startnode.get())
        tempvisited.append(edge)
        if(tempnode==currentnode):
            return currentedge,edge
        else:
            for i in range(len(cells)):
                if(newane[tempnode][i]==1):
                    edge=i          
                    if not(edge in tempvisited):
                        edgeq.put(edge)
                        startnode.put(tempnode)
    return -1,-1
            
                
'''
bnum=int(input("Enter the number of boundary points:"))
bptlist=[]
for i in range(bnum):
    longitude_in=float(input("Enter boundry longitude:"))
    latitude_in=float(input("Enter boundry latitude:"))
    bpt=(longitude_in, latitude_in)
    bptlist.append(bpt)
bpoints=map(Point,bptlist)
boundary=Polygon(*bpoints)
#check if inputs form a polygon
if(checkcrossline(boundary)):
    bptarray=np.array(bptlist)    
    verticearray=formpolygon(bptarray)
    verticelist=verticearray.tolist()
    boundary=Polygon(*verticelist)
    if not (boundary.is_convex()):
        print "please make sure input points are in correct sequence"
'''
'''
#sample1
boundary=Polygon((0,0),(4,0),(4,4),(0,4)) 
'''
'''
#sample2
boundary=Polygon((0,0),(9,0),(9,4),(0,4))
'''
'''
#sample3
boundary=Polygon((0,0),(7,0),(7,4),(0,4)) 
'''
'''
#sample4
boundary=Polygon((0,0),(7,0),(7,4),(5,8),(0,4))  
'''
'''
#sample5
boundary=Polygon((0,0),(7,0),(7,6),(0,6))
'''
'''
#sample6
boundary=Polygon((0,0),(9,0),(9,5),(0,5))
if(boundary.area<0):
    vertices=boundary.vertices
    vertices.reverse()
    boundary=Polygon(*vertices)
'''

ratio=10
#lake Mascoma
bpt=[(0,0.4),(0.55,0.1),(2,0.1),(2.93,0.65),(3.75,0.6),
        (4.05,0.3),(4.55,0.4),(5.25,0.1),(7.1,0.5),(9.3,0.2),
        (10.2,0.75),(11.1,0.75),(11.5,0.4),(13.7,0),(14.5,0.5),
        (15.4,0.1),(16,0.8),(16,1.9),(14.3,1.7),(13.65,2.2),
        (13.3,2.1),(11.4,2.4),(10.7,2),(10.3,2.8),(8.2,3.2),
        (7.8,2.95),(6.5,2.95),(6.75,1.3),(5.3,0.8),(4,1.95),
        (3.2,2.1),(1,0.8),(0.3,0.7)]
bpt=np.array(bpt)
bpt=bpt*ratio
boundary=map(Point,bpt)
boundary=Polygon(*boundary)

#obsnum=int(input("Enter the number of boundary points:"))
obstacles=[]
allinnerpt=[]
obsleft=[]
obsright=[]
'''
#sample1,2
obsnum=1
temppolygon=Polygon((1,2),(2,1),(3,2),(2,3))
obstacles.append(temppolygon)
allinnerpt.extend([[1,2],[2,1],[3,2],[2,3]])
obsleft=[1]
obsright=[3]
iscell=[False]
'''
'''
#sample3
obsnum=1
temppolygon=Polygon((0.8,2),(0.8,1),(2,1),(2,2))
obstacles.append(temppolygon)
allinnerpt.extend([[0.8,2],[0.8,1],[2,1],[2,2]])
obsleft=[0.8]
obsright=[2]
iscell=[False]
'''
'''
#sample4
obsnum=1
temppolygon=Polygon((0.8,2),(0.8,1),(2.3,0.5),(3,2),(2,3))
obstacles.append(temppolygon)
allinnerpt.extend([[0.8,2],[0.8,1],[2.3,0.5],[3,2],[2,3]])
obsleft=[0.8]
obsright=[3]
iscell=[False]
'''
'''
#sample5
obsnum=1
temppolygon=Polygon((1,3),(2,1),(4,2),(2,3))
obstacles.append(temppolygon)
allinnerpt.extend([[1,3],[2,1],[4,2],[2,3]])
obsleft=[1]
obsright=[4]
iscell=[True]
'''
'''
#sample6
obsnum=2
temppolygon=Polygon((1,3),(2,1),(4,2),(2,3))
obstacles.append(temppolygon)
allinnerpt.extend([[1,3],[2,1],[4,2],[2,3]])
temppolygon=Polygon((5,1.5),(7,1.5),(7,4),(5,4))
obstacles.append(temppolygon)
allinnerpt.extend([[5,1.5],[7,1.5],[7,4],[5,4]])
obsleft=[1,5]
obsright=[4,7]
iscell=[False,True]
'''

#lake Mascoma
obsnum=4
temppt=[(8.9,2.5),(9.1,2.4),(9.25,2.5),(9,2.7)]
temppt=np.array(temppt)
temppt=temppt*ratio
temppolygon=map(Point,temppt)
temppolygon=Polygon(*temppolygon)
obstacles.append(temppolygon)
inner=np.array([[8.9,2.5],[9.1,2.4],[9.25,2.5],[9,2.7]])
inner=inner*ratio
allinnerpt.extend(inner)

temppt=[(9.3,2.55),(9.4,2.4),(9.6,2.4),(9.6,2.5),(9.5,2.6)]
temppt=np.array(temppt)
temppt=temppt*ratio
temppolygon=map(Point,temppt)
temppolygon=Polygon(*temppolygon)
obstacles.append(temppolygon)
inner=np.array([[9.3,2.55],[9.4,2.4],[9.6,2.4],[9.6,2.5],[9.5,2.6]])
inner=inner*ratio
allinnerpt.extend(inner)

temppt=[(7,2.4),(7.15,0.9),(8.45,0.5),(9.2,0.5),(10.15,0.9),(10.15,1.7),(8.7,1.9),(7.25,2.6)]
temppt=np.array(temppt)
temppt=temppt*ratio
temppolygon=map(Point,temppt)
temppolygon=Polygon(*temppolygon)
obstacles.append(temppolygon)
inner=np.array([[7,2.4],[7.15,0.9],[8.45,0.5],[9.2,0.5],[10.15,0.9],[10.15,1.7],[8.7,1.9],[7.25,2.6]])
inner=inner*ratio
allinnerpt.extend(inner)

temppt=[(11.75,1.5),(12.4,1),(12.75,1.25),(12.45,2),(11.9,1.85)]
temppt=np.array(temppt)
temppt=temppt*ratio
temppolygon=map(Point,temppt)
temppolygon=Polygon(*temppolygon)
obstacles.append(temppolygon)
inner=np.array([[11.75,1.5],[12.4,1],[12.75,1.25],[12.45,2],[11.9,1.85]])
inner=inner*ratio
allinnerpt.extend(inner)
obsleft=np.array([8.9,9.3,7,11.75])*ratio
obsright=np.array([9.25,9.6,10.15,12.75])*ratio
iscell=[False,False,True,True]

'''
obsleft=np.array([8.9,9.3])*ratio
obsright=np.array([9.25,9.6,])*ratio
iscell=[False,False]
'''
'''
for i in range(obsnum):

    num=int(input( "Enter the number of No %d obstacle points:" %(i+1)))
    left=float('inf')
    right=float('-inf')
    temp=[]
    for j in range(num):
        obsx=float(input("Enter boundry longitude:"))
        obsy=float(input("Enter boundry latitude:"))
        if(obsx<left):
            left=obsx
        if(obsx>right):
            right=obsx
        temp.append([obsx,obsy])
        allinnerpt.append([obsx,obsy])
    temppolygon=Polygon(*temp)
    if(temppolygon.area<0):
        vertices=temppolygon.vertices
        vertices.reverse()
        temppolygon=Polygon(*vertices)
    obstacles.append(temppolygon)
    obsleft.append(left)
    obsright.append(right)
'''

starttime=time.time()
xaxis=Line((0,0),(1,0))
yaxis=Line((0,0),(0,1))
fig=plt.figure()
ax = fig.add_subplot(1,1,1)
ax.set_aspect('equal', 'box')
allinnerpt=np.array(allinnerpt)
allpt=allinnerpt[:]
num=len(boundary.vertices)
#find all critical points and decompose the area
criticalpoints=[]
remain=boundary
bounds=remain.bounds
leftbound=bounds[0]
rightbound=bounds[2]
cut=yaxis.parallel_line(Point(leftbound,0))
cross=boundary.intersection(cut)
if(isinstance(cross[0],Point)):
    criticalpoints.append(cross[0])
else:
    criticalpoints.append(cross[0].midpoint)
for i in range(num):
    pt=boundary.vertices[i]
    cut=yaxis.parallel_line(pt)
    cross=boundary.intersection(cut)
    crosspt=[]
    for item in cross:
        if(isinstance(item,Point)):
            crosspt.append(item)
        else:
            i=0
            for cpt in crosspt:
                if cpt.y<item.p1.y:
                    i=i+1
                    continue
                else:                    
                    crosspt.insert(i,item.p1)
                    crosspt.insert(i,item.p2)
                    break
    if(len(crosspt)>2):
        allpt=np.append(allpt,np.array([pt.x,pt.y]).reshape(1,2),axis=0)      
        if(crosspt.index(pt)==1):            
            if(boundary.vertices[(i+1)%num].x<=pt.x):
                obsright=np.append(obsright,pt.x)
            else:
                obsleft=np.append(obsleft,pt.x)
        else:
            criticalpoints.append(pt) 
            
allpt=allpt[np.lexsort((allpt[:,1],allpt[:,0]))]
cells=[]
cellcost=[]
for pt in allpt:
    isleft=False
    isright=False
    if(pt[0] in obsleft):
        isleft=True
    if(pt[0] in obsright):
        isright=True
    cut=xaxis.perpendicular_line(Point(pt))
    cross=remain.intersection(cut)
    crosspt=[]
    for item in cross:
        if(isinstance(item,Point)):
            crosspt.append(item)
        else:          
            if(len(crosspt)==0):
                crosspt.append(item.p2)
                crosspt.append(item.p1)
            else:
                i=0
                for cpt in crosspt:
                    if cpt.y<item.p1.y:
                        i=i+1
                    else:
                        break
                crosspt.insert(i,item.p1)
                crosspt.insert(i,item.p2)
    if(isright):
        criticalpoints.append(Point(pt))
        if not (Point(pt) in crosspt):
            continue
        elif not(Point(pt) in cross):
            index=crosspt.index(Point(pt))
            seg1=Segment(crosspt[index-1],crosspt[index])
            seg2=Segment(crosspt[index+1],crosspt[index+2])
            cell,remain=splitpolygon(remain,seg1)
            cells.append(cell)
            cell,remain=splitpolygon(remain,seg2)
            cells.append(cell)
        else:
            index=crosspt.index(Point(pt))
            seg1=Segment(crosspt[index-1],crosspt[index])
            seg2=Segment(crosspt[index],crosspt[index+1])
            cell,remain=splitpolygon(remain,seg1)
            cells.append(cell)
            cell,remain=splitpolygon(remain,seg2)
            cells.append(cell)  
    if(isleft):
        criticalpoints.append(Point(pt))
        if (Point(pt) in crosspt):
            continue
        else:
            index=0
            for cpt in crosspt:
                if(cpt.y>pt[1]):
                   break 
                index=index+1
            seg=Segment(crosspt[index-1],crosspt[index])
            cell,remain=splitpolygon(remain,seg)
            if (remain):
                cells.append(cell)
            else:
                remain=cell
            for obs in obstacles:
                if(obs.contains(Point(pt))):
                    break
            remain=minuspolygon(remain,obs,pt)
cells.append(remain)

cut=yaxis.parallel_line(Point(rightbound,0))
cross=boundary.intersection(cut)
if(isinstance(cross[0],Point)):
    criticalpoints.append(cross[0])
else:
    criticalpoints.append(cross[0].midpoint)

#add deeper areas
width=np.ones(len(cells))*0.5
for i in range(obsnum):
    if(iscell[i]):
        cells.append(obstacles[i])
        width=np.append(width,2.4)

#merge critical points that have same x coordinate
formerxpos=criticalpoints[0].x
count=1
ypos=[criticalpoints[0].y]
oldcriticalpoints=criticalpoints[:]
for i in range(1,len(oldcriticalpoints)):
    if(oldcriticalpoints[i].x==formerxpos):
        count=count+1
        ypos.append(oldcriticalpoints[i].y)
    else:
        if(count>1):
            yposmean=sum(ypos)/len(ypos)
            for pt in oldcriticalpoints:
                if (pt.x==formerxpos):
                    criticalpoints.remove(pt)           
            criticalpoints.append(Point(formerxpos,yposmean))
        count=1
        ypos=[oldcriticalpoints[i].y]
        formerxpos=oldcriticalpoints[i].x
        
ane,kn=addtomodel(cells,cellcost,criticalpoints)

m,var=solveLP(cellcost,ane,kn)
printsolution(m,var)

#get copied edges
copiedcell=[]
for f in var:
    if (round(var[f].X,5)!=0):
        if(f[0]=='x'):
            copiedcell.append(f[1])
#update ane matrix   
copiedcell.sort() 
copiedcell.reverse()   
newane=ane  
for c in copiedcell:
    newane=np.insert(newane,c,ane[:,c],axis=1)  
copiedcell.reverse()   

#split the cells
j=0
for c in copiedcell:
    cutpt=[]   
    cutline=[]
    for i in range(len(ane[:,c])):
        if not(ane[i,c]==0):            
            cutpt.append(criticalpoints[i])   
    if(cutpt[0].x>cutpt[1].x):
        cutpt.reverse()
    for side in cells[c+j].sides:
        if(side.p2.x==cutpt[0].x and side.p1.x==cutpt[0].x):
            leftside=side
            break
        elif(side.p2.x==cutpt[0].x):
            if(side.p1.y>side.p2.y):
                leftside=Segment(side.p1,side.p2)
            else:
                leftside=Segment(side.p2,side.p1)
    for side in cells[c+j].sides:            
        if(side.p2.x==cutpt[1].x and side.p1.x==cutpt[1].x):
            rightside=Segment(side.p2,side.p1)
            break
        elif(side.p2.x==cutpt[1].x):
            if(side.p1.y>side.p2.y):
                rightside=Segment(side.p1,side.p2)
            else:
                rightside=Segment(side.p2,side.p1)
    if(leftside.is_parallel(xaxis)):
        leftpartion=1
    else:
        leftpartion=(leftside.p1.y-cutpt[0].y)/(leftside.p1.y-leftside.p2.y)
    if(rightside.is_parallel(xaxis)):
        rightpartion=0
    else:
        rightpartion=(rightside.p1.y-cutpt[1].y)/(rightside.p1.y-rightside.p2.y)
    if((leftpartion==0 and rightpartion==0) or(leftpartion==1 and rightpartion==1)):
        leftpartion=0.5
        rightpartion=0.5
        cutline.append(leftside.midpoint)
        cutline.append(rightside.midpoint)
    else:
        if(leftpartion<0 or leftpartion>1):
            leftpartion=0.5
            cutline.append(leftside.midpoint)
        else:
            cutline.append(cutpt[0])
        if(rightpartion<0 or rightpartion>1):
            rightpartion=0.5
            cutline.append(rightside.midpoint)
        else:
            cutline.append(cutpt[1])
    vertices=sortvertice(cells[c+j].vertices)
    for i in range(1,len(vertices)-1):
        cut=yaxis.parallel_line(vertices[i])
        cross=cells[c+j].intersection(cut)
        if(isinstance(cross[-1],Point)):
            if(cross[0].y>cross[1].y):
                upcross=cross[0]
                downcross=cross[1]
            else:
                upcross=cross[1]
                downcross=cross[0]
            partion=(rightpartion-leftpartion)*(vertices[i].x-leftside.p1.x)/(rightside.p1.x-leftside.p1.x)+leftpartion
            cut=Point(vertices[i].x,upcross.y-(upcross.y-downcross.y)*partion)
            cutline.insert(-1,cut)        
    cell1,cell2=splitCPPpolygon(cells[c+j],cutline)
    cells.remove(cells[c+j])
    cells.insert(c+j,cell1)
    cells.insert(c+j,cell2)
    width=np.insert(width,c+j,width[c+j])
    j=j+1

#generate coverage path
newane=newane.tolist()  
waypoints=[]  
velocity=1
turnpanalty=10
visitededge=[0]
currentnode=0
cellwaypoint=singlearearoute(cells[0],width[0],criticalpoints[0])
waypoints.extend(cellwaypoint)
#greedy algorithm to find the sequence
while(len(visitededge)<len(cells)):
    currentnode=findnext(newane,visitededge[-1],currentnode)
    edgeoptions=[]
    for i in range(len(cells)):
        if(newane[currentnode][i]==1):
            edge=i
            if not(edge in visitededge):
                if not (edge in edgeoptions):
                    cycleedge=checkcycle(newane,visitededge,edge,currentnode)
                    if not(cycleedge[0]==-1):
                        edgeoptions.append(cycleedge[0])
                        edgeoptions.append(cycleedge[1])
    if(len(edgeoptions)==0):
        for i in range(len(cells)):
            if(newane[currentnode][i]==1):
                edge=i
                if not(edge in visitededge):
                    edgeoptions.append(edge)
    mindistance=[]
    for cell in edgeoptions:
        mindist=float('inf')
        for vertice in cells[int(cell)].vertices:           
            distance=Point(waypoints[-1]).distance(vertice)
            if(distance<mindist):
                mindist=distance
        mindistance.append(mindist)
    nextedge=edgeoptions[mindistance.index(min(mindistance))]
        
    cellwaypoint=singlearearoute(cells[nextedge],width[nextedge],waypoints[-1])
    waypoints.extend(cellwaypoint)
    visitededge.append(nextedge)
    
computetime=time.time()-starttime
#plot result
for cell in cells:
    plotpolygon(ax,cell)
plotboundary(ax,boundary)
for i in range(obsnum):
    if not(iscell[i]):
        plotboundary(ax,obstacles[i])
plotline(ax,waypoints,width[0])
waypoints.append(waypoints[0])
totaltime=timeconsume(waypoints,waypoints[0])
turnnum=len(waypoints)-1

print "totaltime: %f" %totaltime
print "number of turn:%f" %turnnum
print "runtime: %f s" %computetime
fig.savefig('CPPadaptive.svg', format='svg', dpi=1200)